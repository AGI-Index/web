-- 1. ENUM 타입 정의 (고정값 설정)
CREATE TYPE agi_category AS ENUM ('linguistic', 'multimodal');
CREATE TYPE unsuitable_reason AS ENUM ('too_broad', 'too_narrow', 'duplicate', 'other');

-- 2. Profiles 테이블 (유저 정보)
CREATE TABLE profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  nickname TEXT,
  is_admin BOOLEAN DEFAULT FALSE, -- 관리자 여부
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 3. Questions 테이블 (AGI 후보 질문)
CREATE TABLE questions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  author_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
  content TEXT NOT NULL,
  category agi_category NOT NULL, -- 작성자가 선택, 관리자가 수정
  
  -- 통계 데이터 (트리거로 자동 계산)
  vote_count INT DEFAULT 0,
  suitable_count INT DEFAULT 0,
  achieved_count INT DEFAULT 0,
  current_weight FLOAT DEFAULT 0,
  
  -- 핵심 상태값
  is_indexed BOOLEAN DEFAULT FALSE, -- Index 등재 여부
  is_achieved BOOLEAN DEFAULT FALSE, -- 달성 여부
  dominant_unsuitable_reason unsuitable_reason, -- 주된 탈락 사유
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 4. Votes 테이블 (투표)
CREATE TABLE votes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  question_id BIGINT REFERENCES questions(id) ON DELETE CASCADE,
  
  is_suitable BOOLEAN NOT NULL,
  unsuitable_reason unsuitable_reason, -- 부적합일 때만 값 있음
  is_achieved BOOLEAN DEFAULT FALSE,   -- 적합일 때만 값 있음
  weight INT CHECK (weight IN (1, 2, 3)), -- 1, 2, 3점
  
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- 한 유저는 한 질문에 한 번만 투표 가능
  UNIQUE(user_id, question_id)
);

-- 5. Daily Metrics 테이블 (매일 밤 스냅샷 저장용)
CREATE TABLE daily_metrics (
  date DATE PRIMARY KEY DEFAULT CURRENT_DATE,
  total_agi_percentage FLOAT,
  linguistic_percentage FLOAT,
  multimodal_percentage FLOAT,
  snapshot_data JSONB, -- 당시 상위 랭킹 질문들 저장
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 6. 보안 정책 (RLS) 설정
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE questions ENABLE ROW LEVEL SECURITY;
ALTER TABLE votes ENABLE ROW LEVEL SECURITY;

-- 6-1. Profiles 정책
CREATE POLICY "Public profiles are viewable by everyone" ON profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile" ON profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile" ON profiles FOR UPDATE USING (auth.uid() = id);

-- 6-2. Questions 정책
CREATE POLICY "Questions are viewable by everyone" ON questions FOR SELECT USING (true);
CREATE POLICY "Authenticated users can insert questions" ON questions FOR INSERT WITH CHECK (auth.role() = 'authenticated');
-- [중요] 관리자만 질문(카테고리 등) 수정 가능
CREATE POLICY "Only admins can update questions" ON questions FOR UPDATE USING (
  (SELECT is_admin FROM profiles WHERE id = auth.uid()) = true
);

-- 6-3. Votes 정책
CREATE POLICY "Votes are viewable by everyone" ON votes FOR SELECT USING (true);
CREATE POLICY "Authenticated users can vote" ON votes FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Users can update own vote" ON votes FOR UPDATE USING (auth.uid() = user_id);


-- 7. 자동화 함수 & 트리거 (핵심 로직)

-- 7-1. 회원가입 시 Profile 자동 생성 트리거
CREATE OR REPLACE FUNCTION public.handle_new_user() 
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, nickname)
  VALUES (new.id, new.raw_user_meta_data->>'full_name');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- 7-2. 투표 시 통계 자동 계산 트리거 (가장 중요!)
CREATE OR REPLACE FUNCTION update_question_stats()
RETURNS TRIGGER AS $$
DECLARE
  _question_id BIGINT;
  _total INT;
  _suitable INT;
  _achieved INT;
  _weight_sum INT;
  _top_reason unsuitable_reason;
BEGIN
  -- 영향받은 질문 ID 찾기
  IF (TG_OP = 'DELETE') THEN
    _question_id := OLD.question_id;
  ELSE
    _question_id := NEW.question_id;
  END IF;

  -- 1. 통계 집계
  SELECT 
    COUNT(*),
    COUNT(*) FILTER (WHERE is_suitable = true),
    COUNT(*) FILTER (WHERE is_suitable = true AND is_achieved = true),
    COALESCE(SUM(weight) FILTER (WHERE is_suitable = true), 0)
  INTO _total, _suitable, _achieved, _weight_sum
  FROM votes
  WHERE question_id = _question_id;

  -- 2. 가장 많은 부적합 사유 찾기
  SELECT unsuitable_reason
  INTO _top_reason
  FROM votes
  WHERE question_id = _question_id AND is_suitable = false
  GROUP BY unsuitable_reason
  ORDER BY COUNT(*) DESC
  LIMIT 1;

  -- 3. Questions 테이블 업데이트 (로직 반영)
  UPDATE questions
  SET 
    vote_count = _total,
    suitable_count = _suitable,
    achieved_count = _achieved,
    current_weight = CASE WHEN _suitable > 0 THEN Round(_weight_sum::numeric / _suitable::numeric, 2) ELSE 0 END,
    dominant_unsuitable_reason = _top_reason,
    
    -- [INDEX 등재 조건] 찬성 10표 이상 AND 찬성률 50% 이상
    is_indexed = CASE 
      WHEN _total > 0 AND _suitable >= 10 AND (_suitable::float / _total::float) >= 0.5 THEN TRUE 
      ELSE FALSE 
    END,
    
    -- [달성 조건] 등재된 상태에서 달성 투표가 전체의 50% 이상 (혹은 적합표의 50%? 여기선 전체 기준 적용)
    is_achieved = CASE 
      WHEN _total > 0 AND (_achieved::float / _total::float) >= 0.5 THEN TRUE 
      ELSE FALSE 
    END
    
  WHERE id = _question_id;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_vote_change
  AFTER INSERT OR UPDATE OR DELETE ON votes
  FOR EACH ROW EXECUTE PROCEDURE update_question_stats();